if(availableToSwitch == 0)
	return FALSE;
if(fn_251E40_J())
	return TRUE;
if(ShouldSwitchIfPerishSong())
	return TRUE;
if(ShouldSwitchIfWonderGuard())
	return TRUE;
if(FindMonThatAbsorbsOpponentsMove())
	return TRUE;
if(ShouldSwitchIfNaturalCure())
	return TRUE;
if(HasSuperEffectiveMoveAgainstOpponents(FALSE))
	return FALSE;
if(AreStatsRaised())
	return FALSE;
if(!CanUseNewAI())
	return FALSE;
if(FindMonWithFlagsAndSuperEffective(MOVE_RESULT_DOESNT_AFFECT_FOE, 2) || FindMonWithFlagsAndSuperEffective(MOVE_RESULT_NOT_VERY_EFFECTIVE, 3))
	return TRUE;
	
return FALSE;








fn_251E40_J()
{
	data_0203B965 = 1

	if(!CanUseNewAI())
		return FALSE;
	if(fn_251E8C_J())
		return TRUE;
	if(fn_251FD0_J())
		return TRUE;
	if(fn_205F48_J())
		return TRUE;
	if(fn_205FDE_J())
		return TRUE;
	if(fn_252058_J())
		return TRUE;
	if(fn_2064C6_J())
		return TRUE;
		
	return FALSE;
}








fn_251E8C_J()
{
	if(gBattleMons[gActiveBattler].ability != 0x90)
	{
		if(gBattleStruct->choicedMove[gActiveBattler])
			lockedMove = gBattleStruct->choicedMove[gActiveBattler];
		elseif(gDisableStructs[gActiveBattler].encoredMove)
			lockedMove = gDisableStructs[gActiveBattler].encoredMove;
		else
			return FALSE;
		
		if(gBattleMoves[lockedMove].power != 0)
		{
			for(i = 0; i < 4; i++)
			{
				if(lockedMove == gBattleMons[gActiveBattler].moves[i])
				{
					if(gBattleMons[gActiveBattler].pp[i] != 0 && (!(AI_TypeCalc(i, gBattleMons[B_POSITION_PLAYER_LEFT].species, gBattleMons[B_POSITION_PLAYER_LEFT].ability) & (MOVE_RESULT_NOT_VERY_EFFECTIVE | MOVE_RESULT_DOESNT_AFFECT_FOE)) || gBattleMons[B_POSITION_PLAYER_LEFT].hp == 0))
					{	
						if(gBattleMons[B_POSITION_PLAYER_RIGHT].hp == 0)
							return FALSE;
						if(!(AI_TypeCalc(i, gBattleMons[B_POSITION_PLAYER_RIGHT].species, gBattleMons[B_POSITION_PLAYER_LEFT].ability) & (MOVE_RESULT_NOT_VERY_EFFECTIVE | MOVE_RESULT_DOESNT_AFFECT_FOE)))
							return FALSE;
					}
					
					break;
				}
			}
		}
		
		if(Random() & 0xF == 0) // 6% chance
			return FALSE;
	}
	else
	{
		if(gBattleMons[gActiveBattler].hp > (gBattleMons[gActiveBattler].maxHP / 2))
			return FALSE;
		if(Random() & 1 == 0) // 50% chance
			return FALSE;
	}
	
	chosenMon = GetMonThatCanWithstandBiggestAttack(GetAITarget(), gActiveBattler)
	
	if(chosenMon == PARTY_SIZE)
	{
		chosenMon = fn_20621C_J(chosenMon)
		
		if(chosenMon == PARTY_SIZE)
		{
			{score, chosenMon} = GetBestMatchupScore(gBattleMons[B_POSITION_PLAYER_LEFT].species, gBattleMons[B_POSITION_PLAYER_RIGHT].species, TRUE);
			
			if(score >= 15) // player mons' types are SE on AI's whole team
				return FALSE;
		}
	}
	
	gBattleStruct->monToSwitchIntoId[gActiveBattler] = chosenMon;
	BtlController_EmitTwoReturnValues(1, 2, 0)
	return TRUE;
}








fn_251FD0_J()
{
	if(!(gBattleMons[gActiveBattler].status2 & STATUS2_CURSED) && !(gStatuses3[gActiveBattler] & STATUS3_YAWN))
		return FALSE;
	if(Random() & 3 == 0) // 25% chance
		return FALSE;

	chosenMon = GetMonThatCanWithstandBiggestAttack(GetAITarget(), gActiveBattler);
	
	if(chosenMon == PARTY_SIZE)
		chosenMon = fn_20621C_J(chosenMon)
	
	gBattleStruct->monToSwitchIntoId[gActiveBattler] = chosenMon;
	BtlController_EmitTwoReturnValues(1, 2, 0)
	return TRUE;
}








fn_205F48_J()
{
	if(!gTrickRoomActive)
		return FALSE;

	if(CanDoSevereDamage(gActiveBattler, GetAITarget(), CHECK_HALF_MAX_HP))
		return FALSE;

	r1 = gBattleMons[gActiveBattler].attack
	r2 = gBattleMons[gActiveBattler].spAttack
	
	if(r1 < r2)
		r1 = r2
	
	if(r1 >= 140)
		return FALSE;

	{r0, chosenMon} = GetBestTrickRoomAttacker()
	
	if(r0 < 140)
		return FALSE;
	if(Random() & 7 == 0) // 12% chance
		return FALSE;

	if(IsMoveSuperEffective(chosenMon, gLastMoves[GetAITarget()]) && (Random() & 7) != 0) // 87% chance
		return FALSE;
	
	gBattleStruct->monToSwitchIntoId[gActiveBattler] = chosenMon;
	BtlController_EmitTwoReturnValues(1, 2, 0)
	return TRUE;
}








fn_205FDE_J()
{
	chosenMon = GetAvailableWeatherSetter();
	
	if(chosenMon != PARTY_SIZE)
	{
		if(Random() & 7 != 0) // 87% chance
		{
			if(CanDoSevereDamage(gActiveBattler, 0, CHECK_IF_KO))
				return FALSE;
			if(CanDoSevereDamage(gActiveBattler, 1, CHECK_IF_KO))
				return FALSE;
		}
		
		if(!(gBattleWeather & 0xFF) && (Random() & 3) == 0) // 25% chance
			return FALSE;
	}
	else
	{
		ability = gBattleMons[gActiveBattler].ability;
		
		if(ability == 2)
			weather = 3
		elseif(ability == 0x2D)
			weather = 0xC
		elseif(ability == 0x46)
			weather = 0x30
		elseif(ability == 0x75)
			weather = 0xC0
		else
			return FALSE;
		
		if(gBattleWeather & weather)
			return FALSE;
		
		{NULL, chosenMon} = GetBestMatchupScore(gBattleMons[B_POSITION_PLAYER_LEFT].0, gBattleMons[B_POSITION_PLAYER_RIGHT].0, 1)
	}
	
	if(Random() % 6 == 0) // 17% chance
		return FALSE;

	gBattleStruct->monToSwitchIntoId[gActiveBattler] = chosenMon;
	BtlController_EmitTwoReturnValues(1, 2, 0)
	return TRUE;
}








fn_252058_J()
{
	r5 = 0
	r6 = 0
	s0 = 0
	
	if((100 * ((gBattleMons[gActiveBattler].speed - 5) / gBattleMons[gActiveBattler].level)) < 290 && gBattleMons[gActiveBattler].hp <= (gBattleMons[gActiveBattler].maxHP / 2))
		return FALSE;

	for(i = B_POSITION_PLAYER_LEFT; i != 4; i += BIT_FLANK)
	{
		if(gBattleMons[i].hp == 0)
			continue;

		r5++
		
		if(!IsMonFasterThan(gActiveBattler, i))
		{
			if(!CanDoSevereDamage(gActiveBattler, i, CHECK_IF_KO))
			{
				{r0, r1} = CanDoSevereDamage(i, gActiveBattler, CHECK_HALF_MAX_HP)
				
				if(!r0)
					continue;
				if(CanDoSevereDamage(gActiveBattler, i, CHECK_IF_KO))
					continue;
			}
		}
		else
		{
			if(CanDoSevereDamage(gActiveBattler, i, CHECK_IF_KO))
				continue;

			if(!CanDoSevereDamage(i, gActiveBattler, CHECK_IF_KO))
			{
				if(CanDoSevereDamage(gActiveBattler, i, CHECK_HALF_MAX_HP))
					continue;
				
				{r0, r1} = CanDoSevereDamage(i, gActiveBattler, CHECK_HALF_MAX_HP)
				
				if(!r0)
					continue;
			}
		}
		
		s0[i] = r1
		r6++
	}
	
	if((Random() % (r5 + 1)) + 1 > r6)
		return FALSE;
	
	if(s0[B_POSITION_PLAYER_LEFT] != 0)
		r4 = s0[B_POSITION_PLAYER_LEFT]
	elseif(s0[B_POSITION_PLAYER_RIGHT] != 0)
		r4 = s0[B_POSITION_PLAYER_RIGHT]
	else
		return FALSE;

	for(i = 0; i < PARTY_SIZE; i++)
	{
		i = GetFirstAllowableSwitchin(i, TRUE);
		
		if(i == PARTY_SIZE)
			break;
		
		if(AI_TypeCalc(r4, GetMonData(gEnemyParty[i], MON_DATA_SPECIES), GetMonAbility(gEnemyParty[i])) & MOVE_RESULT_DOESNT_AFFECT_FOE)
			goto lbl12
	}
	
	for(i = 0; i < PARTY_SIZE; i++)
	{
		i = GetFirstAllowableSwitchin(i, TRUE)
		
		if(i == PARTY_SIZE)
			return FALSE;

		s0 = GetMonData(gEnemyParty[i], MON_DATA_HP)
		
		if(s0 > (s0 / 4) && (GetMonData(gEnemyParty[i], MON_DATA_MAX_HP) != s0 || GetHoldEffectParam(GetMonData(gEnemyParty[i], MON_DATA_HELD_ITEM)) != 0x43))
		{
			if(AI_TypeCalc(r4, GetMonData(gEnemyParty[i], MON_DATA_SPECIES), GetMonAbility(gEnemyParty[i])) & MOVE_RESULT_NOT_VERY_EFFECTIVE)
				goto lbl12
		}
	}
	
	return FALSE;

	lbl12:
	if((Random() % 16) <= data_0203B960_J)
		return FALSE;

	gBattleStruct->monToSwitchIntoId[gActiveBattler] = i;
	BtlController_EmitTwoReturnValues(1, 2, 0)
	return TRUE;
}








fn_2064C6_J()
{
	r5 = 0
	r6 = 0
	
	if((100 * ((gBattleMons[gActiveBattler].speed - 5) / gBattleMons[gActiveBattler].level)) < 290 && gBattleMons[gActiveBattler].hp > (gBattleMons[gActiveBattler].maxHP / 2))
		return FALSE;

	for(i = B_POSITION_PLAYER_LEFT; i != 4; i += BIT_FLANK)
	{
		if(fn_2065CC_J(gActiveBattler))
			continue;
			
		if(!fn_2065CC_J(i))
		{
			if(CanDoSevereDamage(i, gActiveBattler, CHECK_HALF_MAX_HP))
				continue;
			
			{r0, r1} = CanDoSevereDamage(gActiveBattler, i, CHECK_HALF_MAX_HP)
			
			if(r0 == 1)
				continue;
			if(r1 > 0)
				continue;
		}
		elseif(CanDoSevereDamage(gActiveBattler, i, CHECK_HALF_MAX_HP))
			continue;
		
		r6++
	}
	
	if((Random() % (r5 + 1)) + 1 > r6)
		return FALSE;

	chosenMon = fn_205CF6_J(gActiveBattler, GetAITarget())
	
	if(chosenMon == PARTY_SIZE)
		return FALSE;
	
	if(GetMonData(gEnemyParty[chosenMon], MON_DATA_HP) <= (GetMonData(gEnemyParty[chosenMon], MON_DATA_MAX_HP) / 4))
		return FALSE;
	if((Random() % 16) <= data_0203B960_J)
		return FALSE;

	gBattleStruct->monToSwitchIntoId[gActiveBattler] = chosenMon;
	BtlController_EmitTwoReturnValues(1, 2, 0)
	return TRUE;
}








GetAITarget() @2060C0_J
{
	r4 = 0
	
	if(gBattleMons[B_POSITION_PLAYER_LEFT].hp != 0)
		r4 |= 1
	
	if(gBattleMons[B_POSITION_PLAYER_RIGHT].hp != 0)
		r4 |= 2
	
	if(r4 == 3)
		r0 = Random() & 1 // INCORRECT VARIABLE
	elseif(r4 == 1)
		r4--
	
	return r4
	// returns:
		if r4 = 0, B_POSITION_PLAYER_LEFT
		if r4 = 1, B_POSITION_PLAYER_LEFT
		if r4 = 2, B_POSITION_PLAYER_RIGHT
		if r4 = 3, B_POSITION_OPPONENT_RIGHT // should be random B_POSITION_PLAYER_LEFT or B_POSITION_PLAYER_RIGHT
}








GetMonThatCanWithstandBiggestAttack(attacker, defender) @205C80_J
{
	party = GetSideParty(attacker & BIT_SIDE);
	CopyBytes(&gBackupMonData, &gBattleMons[defender], 0x58);
	
	for(i = 0; i < PARTY_SIZE; i++)
	{
		i = GetFirstAllowableSwitchin(i, TRUE)
		
		if(i == PARTY_SIZE)
			break;
		
		CopyMonToBattleMon(&gBattleMons[defender], &party[i])
		
		if(!CanDoSevereDamage(attacker, defender, CHECK_HALF_MAX_HP))
			break;
	}
	
	CopyBytes(&gBattleMons[defender], &gBackupMonData, 0x58);
	return i;
}








fn_20621C_J(startIndex)
{
	for(i = startIndex; i < PARTY_SIZE; i++)
	{
		i = GetFirstAllowableSwitchin(i, TRUE);
		
		if(i == PARTY_SIZE)
			break;
		
		// incorrectly compares stat speed to base speed?
		if(gBattleMons[B_POSITION_PLAYER_LEFT].species != 0 && GetMonData(gEnemyParty[i], MON_DATA_SPEED) > gBaseStats[gBattleMons[B_POSITION_PLAYER_LEFT].species].baseSpeed + 32)
			continue;
		if(gBattleMons[B_POSITION_PLAYER_RIGHT].species != 0 && GetMonData(gEnemyParty[i], MON_DATA_SPEED) > gBaseStats[gBattleMons[B_POSITION_PLAYER_RIGHT].species].baseSpeed + 32)
			continue;
		if(GetMonData(gEnemyParty[i], MON_DATA_HP) <= (GetMonData(gEnemyParty[i], MON_DATA_MAX_HP) / 2))
			break;
	}
	
	return i;
}








CanDoSevereDamage(attacker, target, threshold) @205E14_J
{
	maxDamage = 0;
	gBattlerAttacker = attacker;
	gBattlerTarget = target;

	for(i = 0; i < 4; i++)
	{
		if(gBattleMoves[gBattleMons[gBattlerAttacker].moves[i]].power <= 1)
			continue;

		gDynamicBasePower = 0;
		gBattleStruct->dynamicMoveType = 0;
		gBattleScripting.dmgMultiplier = 1;
		gMoveResultFlags = 0;
		gCritMultiplier = 1;
		gCurrentMove = gBattleMons[gBattlerAttacker].moves[i];
		AI_CalcDmg(gBattlerAttacker, gBattlerTarget, TRUE);
		TypeCalc(gCurrentMove, gBattlerAttacker, gBattlerTarget);
		
		effect = gBattleMoves[gBattleMons[gBattlerAttacker].moves[i]].effect;
		
		if(effect == 0x29)
			gBattleMoveDamage *= 4;
		elseif(effect == 0x2C)
			gBattleMoveDamage *= 2;
		
		if(gBattleMoveDamage > maxDamage)
			maxDamage = gBattleMoveDamage;
		
		if(gBattleMoveDamage == 0)
			gBattleMoveDamage = 1;
		
		if(threshold = CHECK_HALF_MAX_HP)
			r1 = gBattleMons[gBattlerTarget].maxHP / 2
		else
			r1 = gBattleMons[gBattlerTarget].hp
		
		if(gBattleMoveDamage > r1)
			return {1, gBattleMons[gBattlerAttacker].moves[i]};
	}
	
	return {0, 100 * (maxDamage / gBattleMons[gBattlerAttacker].maxHP)};
}








IsMoveSuperEffective(monIndex, move) @206418_J
{
	mon = gPlayerParty[monIndex];
	
	if(AI_TypeCalc(move, GetMonData(mon, MON_DATA_SPECIES), GetMonAbility(mon)) & MOVE_RESULT_SUPER_EFFECTIVE)
		return TRUE;
	else
		return FALSE;
}








IsMonFasterThan(mon1, mon2) @205EE8_J
{
	if(GetSpeedStat(mon2) < GetSpeedStat(mon1))
		return TRUE;
	else
		return FALSE;
}








fn_2065CC_J(mon)
{
	for(i = 0; i < 4; i++)
	{
		effect = gBattleMoves[gBattleMons[mon].moves[i]].effect;

		if(effect == 0x20)
			return TRUE;
		if(effect == 0x84)
			return TRUE;
		if(effect == 0x9D)
			return TRUE;
	}

	return FALSE:
}








fn_205CF6_J(attacker, defender)
{
	party = GetSideParty(attacker & BIT_SIDE);
	CopyBytes(&gBackupMonData, &gBattleMons[defender], 0x58);

	for(i = 0; i < PARTY_SIZE; i++)
	{
		i = GetFirstAllowableSwitchin(i, TRUE);
		
		if(i == PARTY_SIZE)
			break;
		
		CopyMonToBattleMon(&gBattleMons[attacker], &party[i])
		
		if(CanDoSevereDamage(attacker, defender, CHECK_HALF_MAX_HP))
			continue;
		if(!fn_2065CC_J(attacker))
			continue;
		if(!fn_206600_J(attacker, defender))
			continue;
		if(!CanDoSevereDamage(attacker, defender, CHECK_HALF_MAX_HP))
			break;
	}
	
	CopyBytes(&gBattleMons[defender], &gBackupMonData, 0x58);
	return i;
}








CopyMonToBattleMon(destMonID, sourceMon) @205B0C_J
{
	r0 = destMonID
	r1 = 0
	r2 = 0x58
	fn_1E5ED8() // possibly fillWithBytes()?
	
	destMon = *destMonID;
	
	destMon.species = GetMonData(sourceMon, MON_DATA_SPECIES);
	destMon.attack = GetMonData(sourceMon, MON_DATA_ATK);
	destMon.defense  = GetMonData(sourceMon, MON_DATA_DEF);
	destMon.speed = GetMonData(sourceMon, MON_DATA_SPEED);
	destMon.spAttack  = GetMonData(sourceMon, MON_DATA_SPATK);
	destMon.spDefense = GetMonData(sourceMon, MON_DATA_SPDEF);
	destMon.moves[0] = GetMonData(sourceMon, MON_DATA_MOVE1);
	destMon.moves[1] = GetMonData(sourceMon, MON_DATA_MOVE2);
	destMon.moves[2] = GetMonData(sourceMon, MON_DATA_MOVE3);
	destMon.moves[3] = GetMonData(sourceMon, MON_DATA_MOVE4);
	destMon.ivs = GetMonData(sourceMon, MON_DATA_HP_IV) | (GetMonData(sourceMon, MON_DATA_ATK_IV) << 5) | (GetMonData(sourceMon, MON_DATA_DEF_IV) << 0xA) | (GetMonData(sourceMon, MON_DATA_SPEED_IV) << 0xF) | (GetMonData(sourceMon, MON_DATA_SPATK_IV) << 0x14) | (GetMonData(sourceMon, MON_DATA_SPDEF_IV) << 0x19);
	destMon.statStages = 0x0606060606060606;
	destMon.ability = GetMonAbility(sourceMon);
	destMon.type1 = gBaseStats[(GetMonData(sourceMon, MON_DATA_SPECIES)].type1;
	destMon.type2 = gBaseStats[(GetMonData(sourceMon, MON_DATA_SPECIES)].type2;
	destMon.pp[0] = GetMonData(sourceMon, MON_DATA_PP1);
	destMon.pp[1] = GetMonData(sourceMon, MON_DATA_PP2);
	destMon.pp[2] = GetMonData(sourceMon, MON_DATA_PP3);
	destMon.pp[3] = GetMonData(sourceMon, MON_DATA_PP4);
	destMon.hp = GetMonData(sourceMon, MON_DATA_HP);
	destMon.level = GetMonData(sourceMon, MON_DATA_LEVEL);
	destMon.friendship = GetMonData(sourceMon, MON_DATA_FRIENDSHIP);
	destMon.maxHP = GetMonData(sourceMon, MON_DATA_MAX_HP);
	destMon.heldItem = GetMonData(sourceMon, MON_DATA_HELD_ITEM);
	destMon.nickname = 0xFF;
	destMon.otName = 0xFF;
	destMon.personality = GetMonData(sourceMon, MON_DATA_PERSONALITY);
	destMon.otId = GetMonData(sourceMon, MON_DATA_OT_ID);
	return;
}








fn_206600_J(attacker, defender)
{
	if(gBattleMons[defender].status1 & STATUS1_ANY)
		return FALSE;

	for(i = 0; i < 4; i++)
	{
		if(gBattleMons[attacker].pp[i] == 0)
			continue;

		effect = gBattleMoves[gBattleMons[attacker].moves[i]].effect
		
		if(effect == 0x21 || effect == 0x42)
		{
			ability = gBattleMons[defender].ability;
			
			if(ability == 0x11)
				continue;
			if(ability == 0x5A)
				continue;
			if(ability == 0x62)
				continue;

			type1 = gBattleMons[defender].type1;
			
			if(type1 == 8)
				continue;
			if(type1 == 3)
				continue;

			type2 = gBattleMons[defender].type2;
			
			if(type2 == 8)
				continue;
			if(type2 == 3)
				continue;
			
			return TRUE;
		}
		elseif(effect == 0xA7)
		{
			if(gBattleMons[defender].ability == 0x29)
				continue;
			if(gBattleMons[defender].type1 == 0xA)
				continue;
			if(gBattleMons[defender].type2 == 0xA)
				continue;
			
			return TRUE;
		}
		else
			continue;
	}

	return FALSE;
}